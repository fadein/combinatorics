* TODO ={for-each,map,reduce}-{un}ordered-subsets= with optional =k=
  These should cover all cases, right?
  See [[http://stackoverflow.com/questions/2710713/algorithm-to-generate-all-possible-permutations-of-a-list][here]] for permutations; [[http://stackoverflow.com/questions/127704/algorithm-to-return-all-combinations-of-k-elements-from-n][here]] for combinations. Permutations (e.g.
  ordered subsets) look simpler.

  #+BEGIN_SRC scheme
    (use debug
         define-record-and-printer
         srfi-1)
    
    (define ordered-subset-for-each
      (case-lambda
       ((f list)
        (for-each-ordered-subset list (length list)))
       ((f list k)
        (let iter ((list list)
                   (k k) 
                   (subset '()))
          (if (zero? k)
              (f subset)
              (for-each
                  (lambda (element)
                    (iter (delete element list)
                          (sub1 k)
                          (cons element subset)))
                list))))))
    
    (define ordered-subset-fold
      (case-lambda
       ((cons nil list)
        (ordered-subset-fold cons nil list (length list)))
       ((cons nil list k)
        (let ((nil (make-parameter nil)))
          (ordered-subset-for-each
           (lambda (subset)
             (nil (cons subset (nil))))
           list k)
          (nil)))))
    
    (define ordered-subset-map
      (case-lambda
       ((f list) (ordered-subset-map f list (length list)))
       ((f list k)
        (ordered-subset-fold cons '() list k))))
    
  #+END_SRC

  Is =reduce= or =fold= sufficient to implement =for-each= and =map=?

  Let’s make this bitch circular; pop a sentinel on there; and
  recurse.

  Hmm: we either have to copy the list or destroy it to [[http://stackoverflow.com/questions/14678943/scheme-streams-and-circular-lists][make it
  circular]]:

  #+BEGIN_SRC scheme
    (define (circular-list val1 . vals)
      (let ((ans (cons val1 vals)))
        (set-cdr! (last-pair ans) ans)
            ans))
  #+END_SRC

  We can =apply= the list to =circular-list=, but we run up against
  the =apply= ceiling; fuck it, let’s run up against it for now.
